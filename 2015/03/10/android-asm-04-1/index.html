<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>4.1、反射调用与字符串加密 | 吃瓜笔记</title>
    <meta name="author" content="Noverguo">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="Android、Java、ByteCode、ASM、Hack、Nodejs、">
    <meta name="description" content="前言说起混淆，不得不提的是开源工具proguard了。proguard最大的优势在于它会优化你的代码，并删掉无用的类、方法、属性及代码。其次，proguard还会更改你的类名、方法名、属性名，使得反编译后变得难以看懂。但对于有经验的反编译人员或者一些静态分析工具，就变得无能为力了。而另一款收费软件dexguard则提供了更为强大的功能，dexguard是proguard的作者针对android推出的加强版，其包含了proguard的全部功能，而且还提供了加密的功能，如常量字符串加密、入口...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="吃瓜笔记" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">吃瓜笔记</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/asm">
                <span class="nav-text">ASM</span>
            </a>
        
            <a class="nav-item" href="/categories/android">
                <span class="nav-text">Android</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://noverguo.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反射调用属性"><span class="toc-number">2.</span> <span class="toc-text">反射调用属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#转换前"><span class="toc-number">2.0.1.</span> <span class="toc-text">转换前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换后"><span class="toc-number">2.0.2.</span> <span class="toc-text">转换后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换前-1"><span class="toc-number">2.0.3.</span> <span class="toc-text">转换前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换后-1"><span class="toc-number">2.0.4.</span> <span class="toc-text">转换后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换前-2"><span class="toc-number">2.0.5.</span> <span class="toc-text">转换前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换后-2"><span class="toc-number">2.0.6.</span> <span class="toc-text">转换后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换前-3"><span class="toc-number">2.0.7.</span> <span class="toc-text">转换前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换后-3"><span class="toc-number">2.0.8.</span> <span class="toc-text">转换后</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#反射调用方法"><span class="toc-number">3.</span> <span class="toc-text">反射调用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#转换前-4"><span class="toc-number">3.0.1.</span> <span class="toc-text">转换前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换后-4"><span class="toc-number">3.0.2.</span> <span class="toc-text">转换后</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串加密"><span class="toc-number">4.</span> <span class="toc-text">字符串加密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法指令上限问题"><span class="toc-number">5.</span> <span class="toc-text">方法指令上限问题</span></a></li>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            4.1、反射调用与字符串加密
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/2015/03/10/android-asm-04-1/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-03-10T00:00:00.000Z" itemprop="datePublished">2015-03-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说起混淆，不得不提的是开源工具proguard了。proguard最大的优势在于它会优化你的代码，并删掉无用的类、方法、属性及代码。其次，proguard还会更改你的类名、方法名、属性名，使得反编译后变得难以看懂。但对于有经验的反编译人员或者一些静态分析工具，就变得无能为力了。</p>
<p>而另一款收费软件dexguard则提供了更为强大的功能，dexguard是proguard的作者针对android推出的加强版，其包含了proguard的全部功能，而且还提供了加密的功能，如常量字符串加密、入口类加密、本地库加密、资源文件加密等。此外，它还提供了隐藏敏感API的功能，这功能的实现就是通过反射调用并加密字符串来实现的。它还针对Android做了很多优化，如整合了编译流程，编译起来比proguard更快、自动去掉android的Log日志、自动分Dex等。</p>
<h1 id="反射调用属性"><a href="#反射调用属性" class="headerlink" title="反射调用属性"></a>反射调用属性</h1><p>Java的反射调用包括很多方面，如类、属性、方法、注解等，这里我介绍的是针对属性调用与方法调用的反射，下面先介绍反调调用属性。</p>
<p>在bytecode中，获取属性的值使用getstatic和getfield这两条指令，而设置属性的值对应为putstatic和putfield。</p>
<a id="more"></a>
<p>假设有如下Java代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.tencent.asm;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int a = 3;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        a += 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中a+=2;这行代码对应的字节码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GETSTATIC com/tencent/asm/Main.a : I</span><br><span class="line">ICONST_2</span><br><span class="line">IADD</span><br><span class="line">PUTSTATIC com/tencent/asm/Main.a : I</span><br></pre></td></tr></table></figure>

<p>这很好理解，那么如果改成反射调用，那么相应的Java代码又是怎样的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.tencent.asm;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int a = 3;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Field aField = Main.class.getDeclaredField(&quot;a&quot;);</span><br><span class="line">        aField.setInt(null, aField.getInt(null)+2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LDC Lcom/tencent/asm/Main;.class</span><br><span class="line">LDC &quot;a&quot;</span><br><span class="line">INVOKEVIRTUAL java/lang/Class.getDeclaredField (Ljava/lang/String;)Ljava/lang/reflect/Field;</span><br><span class="line">ASTORE 1</span><br><span class="line">ALOAD 1</span><br><span class="line">ACONST_NULL</span><br><span class="line">ALOAD 1</span><br><span class="line">ACONST_NULL</span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Field.getInt (Ljava/lang/Object;)I</span><br><span class="line">ICONST_2</span><br><span class="line">IADD</span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Field.setInt (Ljava/lang/Object;I)V</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这些字节码都是直接通过eclipse的bytecode插件拷贝过来的，建议大家多利用下这个插件。</p>
<p>上面的字节码，是个比较理想的效果，但要写出这种效果，并没想像中那么简单，需要分析上下文才行，大家不妨可以试试自己能不能通过代码自动生成出这样的字节码。</p>
<p>写到这，或许有人听不懂为什么自动生成上面那样的字节码不简单。使用ASM开发时，最简单的就是重写MethodVisitor.visitXXX方法，根据指令来做相应的修改。就像这里，我们可以把getstatic改成对应的多条指令，从而实现反射功能。那么如果我们是使用这种写法的话，需要怎么写呢？</p>
<p>假设这里只处理getstatic指令，我们先看下对应的转换关系：</p>
<h3 id="转换前"><a href="#转换前" class="headerlink" title="转换前"></a>转换前</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSTATIC com/tencent/asm/Main.a : I</span><br></pre></td></tr></table></figure>

<h3 id="转换后"><a href="#转换后" class="headerlink" title="转换后"></a>转换后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LDC Lcom/tencent/asm/Main;.class</span><br><span class="line"></span><br><span class="line">LDC &quot;a&quot;</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/Class.getDeclaredField (Ljava/lang/String;)Ljava/lang/reflect/Field;</span><br><span class="line"></span><br><span class="line">ACONST_NULL</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Field.getInt (Ljava/lang/Object;)I</span><br></pre></td></tr></table></figure>

<p>好像挺简单的，但如果你试下按照上面的方式直接转换putstatic，就会发现有个小问题了——栈中元素前后顺序不对。我们先看下按照上面的方式进行转换的情况：</p>
<h3 id="转换前-1"><a href="#转换前-1" class="headerlink" title="转换前"></a>转换前</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GETSTATIC com/tencent/asm/Main.a : I</span><br><span class="line"></span><br><span class="line">ICONST_2</span><br><span class="line"></span><br><span class="line">IADD</span><br><span class="line"></span><br><span class="line">PUTSTATIC com/tencent/asm/Main.a : I</span><br></pre></td></tr></table></figure>

<h3 id="转换后-1"><a href="#转换后-1" class="headerlink" title="转换后"></a>转换后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LDC Lcom/tencent/asm/Main;.class</span><br><span class="line"></span><br><span class="line">LDC &quot;a&quot;</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/Class.getDeclaredField (Ljava/lang/String;)Ljava/lang/reflect/Field;</span><br><span class="line"></span><br><span class="line">ACONST_NULL</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Field.getInt (Ljava/lang/Object;)I</span><br><span class="line"></span><br><span class="line">ICONST_2</span><br><span class="line"></span><br><span class="line">IADD</span><br><span class="line"></span><br><span class="line">LDC Lcom/tencent/asm/Main;.class</span><br><span class="line"></span><br><span class="line">LDC &quot;a&quot;</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/Class.getDeclaredField (Ljava/lang/String;)Ljava/lang/reflect/Field;</span><br><span class="line"></span><br><span class="line">ACONST_NULL</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Field.setInt (Ljava/lang/Object;I)V</span><br></pre></td></tr></table></figure>

<p>大家对比下，是不是发现问题了？我们这里调用Field.setInt方法时，要求栈中有3个元素，从栈底到栈顶依次是Field对象、null、要设置的值。如果我们还是按上面的转换方法，那么栈中就变成要设置的值、Field对象、null了，这样位置就不对了。</p>
<p>有人说，我直接把ICONST_2和IADD直接插入到ACONST_NULL下面不就行了吗？这样当然可以，但如果想写个自动化程序，这种方案就有点难办了。</p>
<p>我们换个思路，既然我们知道调用putstatic前，栈中必然已经有要设置的值了，那么我们是否可以先把它保存到本地变量中，再根据需要把它加载到栈中呢。这样我们的字节码就变成下面这样：</p>
<h3 id="转换前-2"><a href="#转换前-2" class="headerlink" title="转换前"></a>转换前</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GETSTATIC com/tencent/asm/Main.a : I</span><br><span class="line"></span><br><span class="line">ICONST_2</span><br><span class="line"></span><br><span class="line">IADD</span><br><span class="line"></span><br><span class="line">PUTSTATIC com/tencent/asm/Main.a : I</span><br></pre></td></tr></table></figure>

<h3 id="转换后-2"><a href="#转换后-2" class="headerlink" title="转换后"></a>转换后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LDC Lcom/tencent/asm/Main;.class</span><br><span class="line"></span><br><span class="line">LDC &quot;a&quot;</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/Class.getDeclaredField (Ljava/lang/String;)Ljava/lang/reflect/Field;</span><br><span class="line"></span><br><span class="line">ACONST_NULL</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Field.getInt (Ljava/lang/Object;)I</span><br><span class="line"></span><br><span class="line">ICONST_2</span><br><span class="line"></span><br><span class="line">IADD</span><br><span class="line"></span><br><span class="line">ISTORE 0</span><br><span class="line"></span><br><span class="line">LDC Lcom/tencent/asm/Main;.class</span><br><span class="line"></span><br><span class="line">LDC &quot;a&quot;</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/Class.getDeclaredField (Ljava/lang/String;)Ljava/lang/reflect/Field;</span><br><span class="line"></span><br><span class="line">ACONST_NULL</span><br><span class="line"></span><br><span class="line">ILOAD 0</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Field.setInt (Ljava/lang/Object;I)V</span><br></pre></td></tr></table></figure>

<p>好了，现在可以正常跑了。</p>
<p>问题又来了，上面的字节码中，获取Field功能的字节码是重复的，是不是可以优化掉呢？于是字节码应该变成这样子：</p>
<h3 id="转换前-3"><a href="#转换前-3" class="headerlink" title="转换前"></a>转换前</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GETSTATIC com/tencent/asm/Main.a : I</span><br><span class="line"></span><br><span class="line">ICONST_2</span><br><span class="line"></span><br><span class="line">IADD</span><br><span class="line"></span><br><span class="line">PUTSTATIC com/tencent/asm/Main.a : I</span><br></pre></td></tr></table></figure>

<h3 id="转换后-3"><a href="#转换后-3" class="headerlink" title="转换后"></a>转换后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LDC Lcom/tencent/asm/Main;.class</span><br><span class="line"></span><br><span class="line">LDC &quot;a&quot;</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/Class.getDeclaredField (Ljava/lang/String;)Ljava/lang/reflect/Field;</span><br><span class="line"></span><br><span class="line">ASTORE 1</span><br><span class="line"></span><br><span class="line">ALOAD 1</span><br><span class="line"></span><br><span class="line">ACONST_NULL</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Field.getInt (Ljava/lang/Object;)I</span><br><span class="line"></span><br><span class="line">ICONST_2</span><br><span class="line"></span><br><span class="line">IADD</span><br><span class="line"></span><br><span class="line">ISTORE 0</span><br><span class="line"></span><br><span class="line">ALOAD 1</span><br><span class="line"></span><br><span class="line">ACONST_NULL</span><br><span class="line"></span><br><span class="line">ILOAD 0</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Field.setInt (Ljava/lang/Object;I)V</span><br></pre></td></tr></table></figure>

<p>好了，这样就与我们最理想的情况比较接近了。如果要优化到最理想的情况，就需要分析上下文了。优化又是另外一个话题了，proguard就实现了代码优化，大家可以借鉴下。</p>
<p>下面给出只实现putstatic的ASM代码，其它情况大家自己试着处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectFieldMain implements Opcodes &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ClassReader cr = new ClassReader(new FileInputStream(&quot;a.class&quot;));</span><br><span class="line">        ClassNode newClassNode = new ClassNode();</span><br><span class="line">        cr.accept(new ClassVisitor(ASM5, newClassNode) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">                return new ReflectGetStaticField(ASM5, (MethodNode) super.visitMethod(access, name, desc, signature, exceptions));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">        // 代码中会新增本地变量，ClassWriter.COMPUTE_MAXS可以让ASM框架帮我们重新计算真正的maxLocals</span><br><span class="line">        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        newClassNode.accept(cw);</span><br><span class="line">        // ..保存的代码我就不写了</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static class ReflectGetStaticField extends MethodVisitor &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; fieldIndexMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">        int newLocalIndex;</span><br><span class="line">        public ReflectGetStaticField(int api, MethodNode mn) &#123;</span><br><span class="line">            super(api, mn);</span><br><span class="line">            // 用于新增变量</span><br><span class="line">            newLocalIndex = mn.maxLocals;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void visitCode() &#123;</span><br><span class="line">            super.visitCode();</span><br><span class="line">            Map&lt;String, FieldInsnNode&gt; invokeFields = new HashMap&lt;String, FieldInsnNode&gt;();</span><br><span class="line">            InsnList instructions = ((MethodNode)mv).instructions;</span><br><span class="line">            if(instructions == null || instructions.size() == 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i=0;i&lt;instructions.size();++i) &#123;</span><br><span class="line">                AbstractInsnNode ainode = instructions.get(i);</span><br><span class="line">                if(ainode.getType() == AbstractInsnNode.FIELD_INSN) &#123;</span><br><span class="line">                    FieldInsnNode finode = (FieldInsnNode) ainode;</span><br><span class="line">                    // 去重</span><br><span class="line">                    invokeFields.put(toKey(finode.owner,finode.name,finode.desc), finode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(invokeFields.isEmpty()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            for(FieldInsnNode finode : invokeFields.values()) &#123;</span><br><span class="line">                // 提前保存到本地变量中</span><br><span class="line">                fieldIndexMap.put(toKey(finode.owner,finode.name,finode.desc), newLocalIndex);</span><br><span class="line">                super.visitLdcInsn(Type.getObjectType(finode.owner));</span><br><span class="line">                super.visitLdcInsn(finode.name);</span><br><span class="line">                super.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Class&quot;, &quot;getDeclaredField&quot;, &quot;(Ljava/lang/String;)Ljava/lang/reflect/Field;&quot;, false);</span><br><span class="line">                super.visitVarInsn(ASTORE, newLocalIndex++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        private String toKey(String owner, String name, String desc) &#123;</span><br><span class="line">            return owner + name + desc;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void visitFieldInsn(int opcode, String owner, String name, String desc) &#123;</span><br><span class="line">            if(opcode != PUTSTATIC) &#123;</span><br><span class="line">                super.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Type type = Type.getType(desc);</span><br><span class="line">            // 把栈中的值保存下</span><br><span class="line">            // type.getOpcode(ISTORE)的作用为根据类型获取相应的操作码</span><br><span class="line">            super.visitVarInsn(type.getOpcode(ISTORE), newLocalIndex);</span><br><span class="line">            super.visitVarInsn(ALOAD, fieldIndexMap.get(toKey(owner, name, desc)));</span><br><span class="line">            super.visitInsn(ACONST_NULL);</span><br><span class="line">            super.visitVarInsn(type.getOpcode(ILOAD), newLocalIndex);</span><br><span class="line">            if(type.getSort() &gt;= Type.BOOLEAN &amp;&amp; type.getSort() &lt;= Type.DOUBLE) &#123;</span><br><span class="line">                // 基本数据类型，则使用对应的getXXX方法，这样可以省去对象到基本数据类型的转换</span><br><span class="line">                super.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/reflect/Field&quot;, &quot;get&quot; + getTypeName(type), &quot;(Ljava/lang/Object;)&quot; + type.getDescriptor(), false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                super.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/reflect/Field&quot;, &quot;get&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);</span><br><span class="line">                // 对象类型，需要进行强制类型转换</span><br><span class="line">                super.visitTypeInsn(CHECKCAST, type.getInternalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        private String getTypeName(Type type) &#123;</span><br><span class="line">            switch(type.getSort()) &#123;</span><br><span class="line">            case Type.VOID:</span><br><span class="line">                return &quot;Void&quot;;</span><br><span class="line">            case Type.BOOLEAN:</span><br><span class="line">                return &quot;Boolean&quot;;</span><br><span class="line">            case Type.BYTE:</span><br><span class="line">                return &quot;Byte&quot;;</span><br><span class="line">            case Type.SHORT:</span><br><span class="line">                return &quot;Short&quot;;</span><br><span class="line">            case Type.INT:</span><br><span class="line">                return &quot;Int&quot;;</span><br><span class="line">            case Type.FLOAT:</span><br><span class="line">                return &quot;Float&quot;;</span><br><span class="line">            case Type.LONG:</span><br><span class="line">                return &quot;Long&quot;;</span><br><span class="line">            case Type.DOUBLE:</span><br><span class="line">                return &quot;Double&quot;;</span><br><span class="line">            case Type.OBJECT:</span><br><span class="line">            case Type.ARRAY:</span><br><span class="line">                return &quot;Object&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意下，上面我使用的是Class.getDeclaredField来获取对应的Field，getDeclaredField获取的是类中声明的属性。如果调用的属性是父类的，且它的权限为public的，则可以使用getField方法。非public的父类属性，则可以通过该父类的Class对象的getDeclaredField来查找。</p>
<p>我们平时使用反射时，很多时候会遇到属性没权限访问，这时，就需要调用到相应的setAccessible(true)方法。但这里并不需要，我想这一点不用解释了吧。</p>
<p>另外，复杂一点的方法，都会有很多跳转，如果把获取Field对象的功能都放到最开始的话，运行效率会非常低。当然这功能本来就会非常影响效率，因此建议只在关键地方使用。</p>
<h1 id="反射调用方法"><a href="#反射调用方法" class="headerlink" title="反射调用方法"></a>反射调用方法</h1><p>有了上面反射调用属性的经验，反射调用方法也变得简单很多了。</p>
<p>在bytecode中，调用方法包含多条指令，下面一一解释下：</p>
<p>invokevirtual：调用虚方法指令，此指令可以调用可能有继承关系的方法，除构造方法。</p>
<p>invokestatic：调用静态方法指令。</p>
<p>invokespecial：调用特殊方法指令，如调用构造方法、调用私有实例方法</p>
<p>invokeinterface：调用接口方法指令。</p>
<p>invokedynamic：调用动态方法指令，用于支持动态语言。</p>
<p>需要注意的是，invokedynamic指令在dalvik bytecode目前没有对应的指令，因此不用考虑。</p>
<p>除了invokestatic外，其它指令均至少有一个对象实例的参数，即Java中的this对象。另外，调用的方法中也可以有多个参数。因此，我们首先需要先把栈中相应的内容全部保存到本地变量中，然后通过反射得到对应的Method对象，接着把刚才保存的参数重新压回栈中并调用Method.invoke()方法，最后当然是类型转换拉。</p>
<p>下面是转换前后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectMethodMain &#123;</span><br><span class="line">    public static void add(int a, int b) &#123;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        oldWay();</span><br><span class="line">        newWay();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void oldWay() &#123;</span><br><span class="line">        add(3, 7);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void newWay() throws Exception &#123;</span><br><span class="line">        Method addMethod = ReflectMethodMain.class.getDeclaredMethod(&quot;add&quot;, int.class, int.class);</span><br><span class="line">        addMethod.invoke(null, 3, 7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中oldWay是转换前的，newWay是转换后的。接下来我们对比下转换前后的字节码变化：</p>
<h3 id="转换前-4"><a href="#转换前-4" class="headerlink" title="转换前"></a>转换前</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ICONST_3</span><br><span class="line"></span><br><span class="line">BIPUSH 7</span><br><span class="line"></span><br><span class="line">INVOKESTATIC ReflectMethodMain.add (II)V</span><br><span class="line"></span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure>

<h3 id="转换后-4"><a href="#转换后-4" class="headerlink" title="转换后"></a>转换后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">LDC LReflectMethodMain;.class</span><br><span class="line"></span><br><span class="line">LDC &quot;add&quot;</span><br><span class="line"></span><br><span class="line">ICONST_2</span><br><span class="line"></span><br><span class="line">ANEWARRAY java/lang/Class</span><br><span class="line"></span><br><span class="line">DUP</span><br><span class="line"></span><br><span class="line">ICONST_0</span><br><span class="line"></span><br><span class="line">GETSTATIC java/lang/Integer.TYPE : Ljava/lang/Class;</span><br><span class="line"></span><br><span class="line">AASTORE</span><br><span class="line"></span><br><span class="line">DUP</span><br><span class="line"></span><br><span class="line">ICONST_1</span><br><span class="line"></span><br><span class="line">GETSTATIC java/lang/Integer.TYPE : Ljava/lang/Class;</span><br><span class="line"></span><br><span class="line">AASTORE</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/Class.getDeclaredMethod (Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;</span><br><span class="line"></span><br><span class="line">ASTORE 0</span><br><span class="line"></span><br><span class="line">ALOAD 0</span><br><span class="line"></span><br><span class="line">ACONST_NULL</span><br><span class="line"></span><br><span class="line">ICONST_2</span><br><span class="line"></span><br><span class="line">ANEWARRAY java/lang/Object</span><br><span class="line"></span><br><span class="line">DUP</span><br><span class="line"></span><br><span class="line">ICONST_0</span><br><span class="line"></span><br><span class="line">ICONST_3</span><br><span class="line"></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">AASTORE</span><br><span class="line"></span><br><span class="line">DUP</span><br><span class="line"></span><br><span class="line">ICONST_1</span><br><span class="line"></span><br><span class="line">BIPUSH 7</span><br><span class="line"></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">AASTORE</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/reflect/Method.invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure>

<p>上面我把一些关键点进行了加粗，我们可以看到，我在Java代码中使用的是可变参数的写法，我们知道可变参数实际上是通过数组来实现的，所以bytecode中，使用了数组的方式。</p>
<p>另外，invoke方法接收的是Object对象，因而需要对基本数据类型进行转换。还有一点要注意的是，如果反射调用的方法是void（无返回值），则需要调用一下POP指令，这是因为invoke方法会有一个返回值，如果反射调用的方法返回值为void，那么invoke方法会返回一个null值。</p>
<p>这个是比较理想情况下的转换，但与上面反射调用属性类似，要达到这种效果，需要进行优化。这里同样采用较为简单的方法，下面给出相应的步骤：</p>
<p>1）保存栈中的参数</p>
<p>2）获取待调用方法的Method对象，并压入栈顶</p>
<p>3）产生一个与参数个数同等大小的Object数组，并压入栈顶</p>
<p>4）把参数依次放入到Object数组中，并把参数中的基本数据类型全部转换为相应的对象类型。</p>
<p>5）调用Method.invoke()方法</p>
<p>6）如果返回值是void，则直接调用pop。如果返回值为基本数据类型，则转换为对应的基本数据类型。否则直接强制类型转换为相应的对象类型。</p>
<p>由于这功能简化后代码还是比较多，这里就不贴出来了，大家自己试着实现下，如果有什么不理解的，可联系下我。</p>
<p>我们关注下返回值为基本数据类型的情况。如果返回值就int的，则调用invoke方法后返回的是Integer对象，因此需要先强制类型转换为Integer对象，然后调用Integer.intValue()方法来得到相应的int值。</p>
<h1 id="字符串加密"><a href="#字符串加密" class="headerlink" title="字符串加密"></a>字符串加密</h1><p>这里的字符串加密指的是常量字符串的加密。像上面介绍的反射调用中，类名、属性名、方法名就是常量字符串，此外，开发者在编码时也会经常使用常量字符串。对字符串进行加密，可以隐藏代码中的一些明文，同时也可以结合反射调用来隐藏关键的API调用，增加破解和分析的难度。</p>
<p>下面是加密前的Java代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是加密后的Java代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(decrypt(&quot;Idmmn!Vnsme&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    public static String decrypt(String value) &#123;</span><br><span class="line">        if(value == null || value.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        int code = 1;</span><br><span class="line">        char[] oldBytes = value.toCharArray();</span><br><span class="line">        char[] newBytes = new char[oldBytes.length];</span><br><span class="line">        for(int i=0;i&lt;oldBytes.length;++i) &#123;</span><br><span class="line">            newBytes[i] = (char) (oldBytes[i] ^ code);</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(newBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家在测试时，可能会遇到一些加密后不可打印的甚至是无意义的字符，上面为了能够正常显示，我选了个可以打印的加密结果。</p>
<p>我们看到，加密后的代码多了一个解密方法，另外常量字符串也变为了一个加密过无意义的常量字符串了，而在使用常量字符串前，使用了解密方法进行解密。</p>
<p>上面使用了一个简单的异或加密方案，此方案加密与解密代码是完全一样的，即为可逆算法。有兴趣的童鞋可以把它改为更加复杂的算法，下面给出对应的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">package com.tencent.asm;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import org.objectweb.asm.ClassReader;</span><br><span class="line">import org.objectweb.asm.ClassVisitor;</span><br><span class="line">import org.objectweb.asm.Label;</span><br><span class="line">import org.objectweb.asm.MethodVisitor;</span><br><span class="line">import org.objectweb.asm.Opcodes;</span><br><span class="line">import org.objectweb.asm.tree.ClassNode;</span><br><span class="line">import org.objectweb.asm.tree.MethodNode;</span><br><span class="line">public class EncryptStringMain implements Opcodes  &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ReflectFieldMain.class.getDeclaredField(&quot;&quot;).setAccessible(true);</span><br><span class="line">        ClassReader cr = new ClassReader(new FileInputStream(&quot;EncryptStringMain.class&quot;));</span><br><span class="line">        ClassNode oldClassNode = new ClassNode();</span><br><span class="line">        cr.accept(oldClassNode, 0);</span><br><span class="line">        final ClassNode newClassNode = new ClassNode();</span><br><span class="line">        final MethodNode decryptMethodNode = newDecryptMethod();</span><br><span class="line">        oldClassNode.accept(new ClassVisitor(ASM5, newClassNode) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public MethodVisitor visitMethod(int access, final String name, final String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">                return new MethodVisitor(ASM5, super.visitMethod(access, name, desc, signature, exceptions)) &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void visitLdcInsn(Object cst) &#123;</span><br><span class="line">                        if(!(cst instanceof String)) &#123;</span><br><span class="line">                            super.visitLdcInsn(cst);</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 这行代码在这里是永远不会执行到，这里只是为了提醒大家，注意不要生成递归调用了</span><br><span class="line">                        if(name.equals(decryptMethodNode.name) &amp;&amp; desc.equals(decryptMethodNode.desc)) &#123;</span><br><span class="line">                            super.visitLdcInsn(cst);</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 加载加密后的字符串</span><br><span class="line">                        super.visitLdcInsn(encrypt((String)cst));</span><br><span class="line">                        // 调用解密方法进行解密</span><br><span class="line">                        super.visitMethodInsn(INVOKESTATIC, newClassNode.name, decryptMethodNode.name, decryptMethodNode.desc, false);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        newClassNode.methods.add(decryptMethodNode);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    private static MethodNode newDecryptMethod() &#123;</span><br><span class="line">        // 这里代码很长，建议不要自己写，而是直接使用eclipse的bytecode插件的ASM功能来拷</span><br><span class="line">        MethodNode decryptMethodNode = new MethodNode(ACC_PUBLIC + ACC_STATIC, &quot;_&quot; + System.currentTimeMillis(), &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, null, null);</span><br><span class="line">        decryptMethodNode.visitCode();</span><br><span class="line">        decryptMethodNode.visitVarInsn(ALOAD, 0);</span><br><span class="line">        Label label0 = new Label();</span><br><span class="line">        decryptMethodNode.visitJumpInsn(IFNULL, label0);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ALOAD, 0);</span><br><span class="line">        decryptMethodNode.visitLdcInsn(&quot;&quot;);</span><br><span class="line">        decryptMethodNode.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false);</span><br><span class="line">        Label label1 = new Label();</span><br><span class="line">        decryptMethodNode.visitJumpInsn(IFEQ, label1);</span><br><span class="line">        decryptMethodNode.visitLabel(label0);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ALOAD, 0);</span><br><span class="line">        decryptMethodNode.visitInsn(ARETURN);</span><br><span class="line">        decryptMethodNode.visitLabel(label1);</span><br><span class="line">        decryptMethodNode.visitInsn(ICONST_1);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ISTORE, 1);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ALOAD, 0);</span><br><span class="line">        decryptMethodNode.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;toCharArray&quot;, &quot;()[C&quot;, false);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ASTORE, 2);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ALOAD, 2);</span><br><span class="line">        decryptMethodNode.visitInsn(ARRAYLENGTH);</span><br><span class="line">        decryptMethodNode.visitIntInsn(NEWARRAY, T_CHAR);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ASTORE, 3);</span><br><span class="line">        decryptMethodNode.visitInsn(ICONST_0);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ISTORE, 4);</span><br><span class="line">        Label label2 = new Label();</span><br><span class="line">        decryptMethodNode.visitJumpInsn(GOTO, label2);</span><br><span class="line">        Label label3 = new Label();</span><br><span class="line">        decryptMethodNode.visitLabel(label3);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ALOAD, 3);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ILOAD, 4);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ALOAD, 2);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ILOAD, 4);</span><br><span class="line">        decryptMethodNode.visitInsn(CALOAD);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ILOAD, 1);</span><br><span class="line">        decryptMethodNode.visitInsn(IXOR);</span><br><span class="line">        decryptMethodNode.visitInsn(I2C);</span><br><span class="line">        decryptMethodNode.visitInsn(CASTORE);</span><br><span class="line">        decryptMethodNode.visitIincInsn(4, 1);</span><br><span class="line">        decryptMethodNode.visitLabel(label2);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ILOAD, 4);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ALOAD, 2);</span><br><span class="line">        decryptMethodNode.visitInsn(ARRAYLENGTH);</span><br><span class="line">        decryptMethodNode.visitJumpInsn(IF_ICMPLT, label3);</span><br><span class="line">        decryptMethodNode.visitTypeInsn(NEW, &quot;java/lang/String&quot;);</span><br><span class="line">        decryptMethodNode.visitInsn(DUP);</span><br><span class="line">        decryptMethodNode.visitVarInsn(ALOAD, 3);</span><br><span class="line">        decryptMethodNode.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/String&quot;, &quot;&lt;init&gt;&quot;, &quot;([C)V&quot;, false);</span><br><span class="line">        decryptMethodNode.visitInsn(ARETURN);</span><br><span class="line">        decryptMethodNode.visitEnd();</span><br><span class="line">        return decryptMethodNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static String encrypt(String value) &#123;</span><br><span class="line">        if(value == null || value.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        int code = 1;</span><br><span class="line">        char[] oldBytes = value.toCharArray();</span><br><span class="line">        char[] newBytes = new char[oldBytes.length];</span><br><span class="line">        for(int i=0;i&lt;oldBytes.length;++i) &#123;</span><br><span class="line">            newBytes[i] = (char) (oldBytes[i] ^ code);</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(newBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，我就不解释了。结合前面的反射调用功能，就可以实现针对性地隐藏关键系统API调用。</p>
<h1 id="方法指令上限问题"><a href="#方法指令上限问题" class="headerlink" title="方法指令上限问题"></a>方法指令上限问题</h1><p>首先，无论是正常调用改为反射调用还是字符串加密，必然会增加字节码，而Java每个方法的代码是不能超过65536个字节的，这一点我们可以从ASM框架中的MethodWriter.getSize()方法而看出来。下面是MethodWriter的关键代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package org.objectweb.asm;</span><br><span class="line">...</span><br><span class="line">class MethodWriter extends MethodVisitor &#123;</span><br><span class="line">    ...</span><br><span class="line">    private ByteVector code = new ByteVector();</span><br><span class="line">    ...</span><br><span class="line">    MethodWriter(final ClassWriter cw, final int access, final String name, final String desc, final String signature, final String[] exceptions, final boolean computeMaxs, final boolean computeFrames) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    final int getSize() &#123;</span><br><span class="line">            ...</span><br><span class="line">        if (code.length &gt; 0) &#123;</span><br><span class="line">            if (code.length &gt; 65536) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;Method code too large!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，当前方法的长度可以通过code.length来得到，不过有点麻烦的是，code属性的权限是private的，而MethodWriter类是package的，还有的是，MethodWriter的构造方法也是package的，且参数中要求一个ClassWriter类的实例。</p>
<p>下面提供一种获取当前方法的长度的方案以及获取某条指令占用的字节数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.objectweb.asm;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import org.objectweb.asm.tree.AbstractInsnNode;</span><br><span class="line">import org.objectweb.asm.tree.MethodNode;</span><br><span class="line">public class CodeLengthUtil &#123;</span><br><span class="line">    // 获取方法的长度</span><br><span class="line">    public static int getCodeLength(MethodNode mn) throws Exception &#123;</span><br><span class="line">        MethodWriter mw = new MethodWriter(new ClassWriter(ClassWriter.COMPUTE_MAXS), mn.access, mn.name, mn.desc, mn.signature, mn.exceptions.toArray(new String[0]), true, false);</span><br><span class="line">        mn.accept(mw);</span><br><span class="line">        return getLength(mw);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取某条指令的长度</span><br><span class="line">    public static int getCodeLength(AbstractInsnNode ainode) throws Exception &#123;</span><br><span class="line">        MethodWriter mw = new MethodWriter(new ClassWriter(ClassWriter.COMPUTE_MAXS), 0, &quot;a&quot;, &quot;()V&quot;, null, null, true, false);</span><br><span class="line">        ainode.accept(mw);</span><br><span class="line">        return getLength(mw);</span><br><span class="line">    &#125;</span><br><span class="line">    private static int getLength(MethodWriter mw) throws Exception &#123;</span><br><span class="line">        Field codeField = MethodWriter.class.getDeclaredField(&quot;code&quot;);</span><br><span class="line">        codeField.setAccessible(true);</span><br><span class="line">        ByteVector bv = (ByteVector) codeField.get(mw);</span><br><span class="line">        return bv.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，上面CodeLengthUtil所在的包为org.objectweb.asm，即与MethodWriter在同一个包，如果不在同一个包中，则会更多的地方会需要使用反射。当然，ASM是开源的，大家直接改下它的源码也行，甚至直接修改ASM库也是可以的。</p>
<p>有了上面的工具，我们可以先获取原方法的长度，然后获得需要增加的指令的总长度，再加起来与65536比较，如果超了，就看着处理哈。</p>

        
    </section>
</article>



<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "3b0fec87adc210be5c53",
        clientSecret: "20204fc5d8a6988ef125a8057fc5073ad5f0a0f0",
        repo: "noverguo.github.io",
        owner: "noverguo",
        admin: ["noverguo"],
        id: "2015/03/10/android-asm-04-1",
        distractionFreeMode: true,
        title: "4.1、反射调用与字符串加密",
        body: "http://noverguo.github.io/2015/03/10/android-asm-04-1/",
        labels: ["ASM","bytecode","Android"]
    }).render('comments');
    </script>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?477943ae26be21251c9ee3fdca3ed5bd";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    
        <script type="text/javascript" src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});
        </script>
    

</body>
</html>
