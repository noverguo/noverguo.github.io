<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Category: asm | 吃瓜笔记</title>
    <meta name="author" content="Noverguo">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="Android、Java、ByteCode、ASM、Hack、Nodejs、">
    <meta name="description" content="一些不常用的技术笔记。记忆差没关系，有笔记兜底">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="吃瓜笔记" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">吃瓜笔记</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item active" href="/categories/asm">
                <span class="nav-text">ASM</span>
            </a>
        
            <a class="nav-item" href="/categories/android">
                <span class="nav-text">Android</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://noverguo.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="Noverguo">
                </a>
            </div>
            
            <div class="author-name">Noverguo</div>
            <div class="author-work">Android &amp; Web &amp; nodejs Developer</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Guangzhou, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                        <a class="thread-item" href="https://github.com/noverguo" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"/>
</svg>

                        </a>
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/09/10/fixjarbug/">基于ASM修复Jar包的Bug(修改class文件)</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-09-10T00:00:00.000Z" itemprop="datePublished">2019-09-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Bytecode/">Bytecode</a>, <a class="article-tag-link" href="/tags/Jar包/">Jar包</a>, <a class="article-tag-link" href="/tags/修改class/">修改class</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>同事发现了一个crash是来源于公司内某个闭源jar的，而负责此Jar开发的同事已经离职，难以找人修复，于是就想找我帮忙弄下。<br>想修改class文件，方式很多，如Javassist、ASM等</p>
<ul>
<li>Javassist的修改是基于源代码，因此更容易上手，可参考<a href="https://www.cnblogs.com/baby123/p/10871154.html" target="_blank" rel="noopener">修改jar的.class文件，并重新打包</a></li>
<li>ASM则是直接基于java bytecode，复杂性相对高些，但几乎无所不能。若能理解ASM的设计的话，使用也并不复杂，不懂的可参考<a href="/2015/01/13/android-asm-02-3/" title="ASM库的介绍">ASM库的介绍</a>
        
        <p class="article-more-link">
            <a href="/2019/09/10/fixjarbug/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </li></ul></section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2015/06/01/android-asm-05/">5、总结</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-06-01T00:00:00.000Z" itemprop="datePublished">2015-06-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>本系列文章到这里就已经到尾声了，在第二章时，我给大家介绍了很多相关的知识，这些知识是学习本系列文章的基础。接着在第三章中，我介绍了目前流行的相似度识别方案，并针对网上没开源的方案进行简单模拟实现。之后在第四章中，我介绍了一些代码混淆的方案，这些方案只是给大家个引子，希望大家能够举一反三，想出更多更好的方案。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>现在我们已经能够把代码混淆得面目全非了，但是怎么才能知道它的混淆效果了呢？一般做法有两种，一是人工分析，二是通过工具自动化分析。</p>
<p>人工分析很难有个衡量标准，所以这里我打算使用工具自动化分析。在第三章中，我介绍了一些相似度分析工具，这里我就用那三个相似度分析工具进行分析，并比较。</p>
<p>接下来使用的混淆工具，都进行了随机混淆处理，也就是说两次分别处理的应用，混淆效果是不一样的，而后面的分析结果，除重打包是基于处理前后的应用外，其它都是基于两次分别处理的应用。</p>
<p>下面是开源中国的测试结果：</p>
        
        <p class="article-more-link">
            <a href="/2015/06/01/android-asm-05/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2015/05/11/android-asm-04-5/">4.5、重构为本地方法</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-05-11T00:00:00.000Z" itemprop="datePublished">2015-05-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JNI（Java Native Interface）意为Java本地接口，我们可以通过JNI来实现Java与C/C++之间互调。</p>
<p>前面我们介绍了重构方法的方案，不过重构后的方法仍然是Java方法，因此分析起来相对也比较容易。</p>
<p>这一章我将介绍的是重构到本地方法中，即需要把字节码转换为本地代码。</p>
<h1 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h1><table>
<thead>
<tr>
<th>实现方案</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>方案一</td>
<td>把字节码直接转换为相应的汇编代码</td>
<td>字节码是基于栈的，而汇编中直接支持栈的操作，因此实现比较容易且运行效率非常高。 汇编代码不跨平台，因而需要针对每个平台来编写对应的汇编代码。</td>
</tr>
<tr>
<td>方案二</td>
<td>把字节码转换为相应的C/C++代码 跨平台，实现起来比较简单。</td>
<td>运行效率相对较低。</td>
</tr>
</tbody></table>
<p>如果是为了做优化，建议选择方案一，但如果只是为了混淆，那么方案二是个好选择，毕竟编程起来更容易，也更好维护。这里选择的是方案二。</p>
<p>另外，这里选择使用C，因为C编译出来的体积更少。</p>
        
        <p class="article-more-link">
            <a href="/2015/05/11/android-asm-04-5/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2015/05/01/android-asm-04-4/">4.4、合并方法</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-05-01T00:00:00.000Z" itemprop="datePublished">2015-05-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>合并方法指的是把多个方法合并成一个方法，从而达到减少方法数量，增加分析难度的目的。</p>
<p>前面提到过，Android中Dex有65536个方法数量的限制，因而进行方法合并有利于缓解此限制。另外上一章提到的重构方法方案会大量的增加方法，如果把增加的方法进行合并，那么可缓解增加方法的数量。</p>
<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p>合并方法时，需要修改合并后的方法签名，而有些方法是对外提供的接口，是不能合并的。如Android中的Activity等四大组件中继承的一些特定方法，插件化框架中对外提供的接口等等。</p>
<h1 id="被合并方法选择"><a href="#被合并方法选择" class="headerlink" title="被合并方法选择"></a>被合并方法选择</h1><p>1、只要被Proguard混淆过的方法，大部分都可以进行合并，而未混淆的代码，则由于可能有各种各样的潜规则（如JNI或其它地方反射调用该方法、作为插件化框架所提供的接口等），而需要通过配置Keep住。</p>
<p>2、没继承关系的方法，皆可进行处理。</p>
<p>3、有继承关系的方法，虽有部分能处理，但经测试量较少，且处理成本非常大，因而不建议处理。</p>
<p>4、重构产生的方法，均可以进行合并处理</p>
        
        <p class="article-more-link">
            <a href="/2015/05/01/android-asm-04-4/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2015/03/16/android-asm-04-2/">4.2、指令替换与花指令</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-03-16T00:00:00.000Z" itemprop="datePublished">2015-03-16</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Java开发的过程中，一般是通过javac工具把Java代码编译成字节码。在编译的过程中，每一种语法都会有一一对应的指令组合起来。只要熟悉这一对应关系，就完全能够通过字节码猜出它对应的Java代码。这时，我们可以通过指令等价替换或者增加无意义的花指令的方式，把正常的写法改成javac不会产生的写法，从而加大破解分析的难度。</p>
<h1 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a>指令替换</h1><p>指令替换意为指令的等价替换，即把一条或多条指令替换为等价的一条或多条指令。</p>
<p>指令替换的方式多种多样，它有可能会增加指令的数量，也有可能会减少指令的数量。有可能会增大或减少方法代码的字节数，有可能会加快或减低代码的执行速度。</p>
<p>下面我讲解几种指令替换方案：</p>
        
        <p class="article-more-link">
            <a href="/2015/03/16/android-asm-04-2/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2015/03/10/android-asm-04-3/">4.3、重构方法</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-03-10T00:00:00.000Z" itemprop="datePublished">2015-03-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在各种IDE中，都会有重构代码到一个新方法的选项（以下简称为重构方法），如下面是eclipse的重构功能：<br><img src="/img/ec-refactor.png" alt></p>
<p>重构方法可重复利用代码，优化软件设计，提高代码的可读性，使得功能扩展更容易等等。当然，过度地重构会使得代码变得难以阅读，难以定位出错的原因。</p>
<h1 id="可重构分析"><a href="#可重构分析" class="headerlink" title="可重构分析"></a>可重构分析</h1><p>在进行重构之前，我们需要先分析方法中哪些代码是可以重构。可重构的代码有几个特点：</p>
<p>1）不应该包含返回指令（因为此时还未知该代码重构后的返回值是什么）。</p>
<p>2）重构代码外的跳转指令不能跳转到重构代码中，重构代码中的跳转指令只能跳转到重构代码中。</p>
<p>3）代码前后堆栈平衡。</p>
<p>4）最多只能有一个返回值，但可有多个参数。</p>
        
        <p class="article-more-link">
            <a href="/2015/03/10/android-asm-04-3/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2015/03/10/android-asm-04-1/">4.1、反射调用与字符串加密</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-03-10T00:00:00.000Z" itemprop="datePublished">2015-03-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说起混淆，不得不提的是开源工具proguard了。proguard最大的优势在于它会优化你的代码，并删掉无用的类、方法、属性及代码。其次，proguard还会更改你的类名、方法名、属性名，使得反编译后变得难以看懂。但对于有经验的反编译人员或者一些静态分析工具，就变得无能为力了。</p>
<p>而另一款收费软件dexguard则提供了更为强大的功能，dexguard是proguard的作者针对android推出的加强版，其包含了proguard的全部功能，而且还提供了加密的功能，如常量字符串加密、入口类加密、本地库加密、资源文件加密等。此外，它还提供了隐藏敏感API的功能，这功能的实现就是通过反射调用并加密字符串来实现的。它还针对Android做了很多优化，如整合了编译流程，编译起来比proguard更快、自动去掉android的Log日志、自动分Dex等。</p>
<h1 id="反射调用属性"><a href="#反射调用属性" class="headerlink" title="反射调用属性"></a>反射调用属性</h1><p>Java的反射调用包括很多方面，如类、属性、方法、注解等，这里我介绍的是针对属性调用与方法调用的反射，下面先介绍反调调用属性。</p>
<p>在bytecode中，获取属性的值使用getstatic和getfield这两条指令，而设置属性的值对应为putstatic和putfield。</p>
        
        <p class="article-more-link">
            <a href="/2015/03/10/android-asm-04-1/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2015/03/04/android-asm-03-2/">3.2、基于API序列与基于变量计数的相似度分析</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-03-04T00:00:00.000Z" itemprop="datePublished">2015-03-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一章中我给大家介绍了基于代码流的方案，这一章里，我将会介绍基于API序列与基于变量计数的方案。</p>
<p>由于这两种方案目前在网上还未能找到针对Dex的开源实现，所以这里我会简单介绍下其原理实现。</p>
<h1 id="基于API序列的原理"><a href="#基于API序列的原理" class="headerlink" title="基于API序列的原理"></a>基于API序列的原理</h1><p>API（Application Programming Interface）一般指的是系统或他人提供的编程接口。</p>
<p>这里我把API定义为所有被调用的方法，在我们编写代码的过程中，一般情况下都会调用各种API，这些API可以分为三类：</p>
<p>1) 系统API</p>
<p>2) 别人提供的SDK或开源库中的API</p>
<p>3) 自己编写的API。</p>
        
        <p class="article-more-link">
            <a href="/2015/03/04/android-asm-03-2/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2015/02/27/android-asm-03-1/">3.1、基于代码流的相似度分析</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-02-27T00:00:00.000Z" itemprop="datePublished">2015-02-27</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里所说的相似度分析是针对Android应用来说的，主要是指Dex文件的分析。</p>
<p>通过相似度分析，可以快速地识别一款应用是否来源于另一款应用，如版本更新、重打包之类的。这对于病毒分析、重打包分析等非常之有用。</p>
<p>目前市面上主流的相似度分析方案有3种：基于代码流、基于API序列、基于变量计数。本章将介绍基于代码流的方案。</p>
<p>基于代码流的方案是指针对同一个方法中的多条指令进行连续性识别，Androguard中的androsim.py工具就是基于这种原理。当然，有了前面的知识，我们也可以自己写一个类似的工具。</p>
<h1 id="androsim-py的使用"><a href="#androsim-py的使用" class="headerlink" title="androsim.py的使用"></a>androsim.py的使用</h1><p>androsim.py是Androguard中的一个工具，因此需要先安装Androguard。Androguard下载与安装请参见官方文档：<a href="http://code.google.com/p/androguard/" target="_blank" rel="noopener">http://code.google.com/p/androguard/</a></p>
        
        <p class="article-more-link">
            <a href="/2015/02/27/android-asm-03-1/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2015/02/11/android-asm-02-5/">android代码混淆系列文章-2.5、asm、asmdex、smali/baksmali的优劣对比</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://noverguo.github.io/categories/asm/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-02-11T00:00:00.000Z" itemprop="datePublished">2015-02-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ASM/">ASM</a>, <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/bytecode/">bytecode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几章中我们分别介绍asm、asmdex以及smali/baksmali这三个开源库，它们各有其特色之处，这一章我们来对比一下它们的优劣，以便更好地选择方案进行开发。</p>
<h1 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h1><p>asm修改的是class文件，所以无法直接修改android应用，不过幸运的是，我们可以通过dex2jar进行转换。但这样一来，就相当于同时依赖asm和dex2jar了。这样我们开发过程中就需要对asm和dex2jar都保持怀疑的态度，以免由于asm或dex2jar的Bug而影响到开发的效率。</p>
<p>幸运的是，asm5.0版非常地成熟，到目前还没发现Bug，而dex2jar0.95版有一点Bug，但更新到2.0版后，至今也没发现有严重的Bug。不过dex2jar有个小问题，就是不支持保留行号和调试信息。</p>
        
        <p class="article-more-link">
            <a href="/2015/02/11/android-asm-02-5/#more">
                <span class="vm">查看全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>




<nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/categories/asm/page/2/">2</a><a class="extend next" rel="next" href="/categories/asm/page/2/">下一页 &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?477943ae26be21251c9ee3fdca3ed5bd";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    

</body>
</html>
